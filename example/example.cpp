#include <fstream>
#include <iostream>

#include "nbt.hpp"

static Nbt::Tag readNbt(const std::string &filepath, bool isBigEndian) {
    std::ifstream is(filepath, std::ios_base::binary);

    if (!is.is_open())
        return;

    // The NBT root tag should is a List or Compound.
    Nbt::Tag nbt(Nbt::Compound, is, isBigEndian);       // Construct a Compound from the input stream.
    is.close();
    return nbt;
}

static Nbt::Tag getExampleCompound() {
    using namespace Nbt;

    // Get the root of nbt. (that is 'Compound Tag' of root)
    Nbt::Tag root = Nbt::gCompound("");

    // Add some base datas to 'root'.
    root << gByte("This is a Byte", 1);
    root << gInt("This is a Int", 10);
    root << gDouble("This is a Double", 3.1415926);
    root << gString("This is a String", "hello, world");

    // Add 'Long Array' with 5 element to 'root'.
    root << gLongArray("This is a Long Array");
    for (int i = 0; i < 5; ++i)
        root.back().addLong(i * 100000);

    // Add 'List' with 5 element to 'root'.
    root << gList("This is a List", Int);
    for (int i = 0; i < 5; ++i)
        root.back() << gpInt(i);        // A tag that will be add to 'List' should used 'Pure Data'.

    // Add 'Compound' to 'root'.
    root << gCompound("This is a Sub Compound");

    // Add some datas to sub compound.
    root.back().addMember(gShort("This is a Short and it generated by function of addMember()", 16));
    root.back().addMember(gByteArray("This is a empty Byte Array"));
    root.back().addMember(gList("This is a empty List", End));
    root.back().addMember(gCompound("This is a empty Compound"));

    return root;
}

static void getAllTypeFiles(const Nbt::Tag &tag) {
    std::string outpath;
    std::cout << "Please input the 'Output Directory Path':" << std::endl;
    std::cin >> outpath;

    std::ofstream BigEndianCompressed(outpath + "/BigEndian_Compressed.nbt", std::ios_base::binary);
    std::ofstream BigEndianUncompressed(outpath + "/BigEndian_Uncompressed.nbt", std::ios_base::binary);
    std::ofstream LittleEndianCompressed(outpath + "/LittleEndian_Compressed.nbt", std::ios_base::binary);
    std::ofstream LittleEndianUncompressed(outpath + "/LittleEndian_Uncompressed.nbt", std::ios_base::binary);
    std::ofstream SnbtWithIndent(outpath + "/SNBT_With_Indent.txt");
    std::ofstream SnbtNoIndent(outpath + "/SNBT_No_Indent.txt");

    tag.write(BigEndianCompressed, true, true);
    tag.write(BigEndianUncompressed, true, false);
    tag.write(LittleEndianCompressed, false, true);
    tag.write(LittleEndianUncompressed, false, false);
    SnbtWithIndent << tag.toSnbt(true);
    SnbtNoIndent << tag.toSnbt(false);

    BigEndianCompressed.close();
    BigEndianUncompressed.close();
    LittleEndianCompressed.close();
    LittleEndianUncompressed.close();
    SnbtWithIndent.close();
    SnbtNoIndent.close();
}

int main(){
    std::cout << "The Part 1<Read A NBT And Print SNBT>\n---------------------------------" << std::endl;
    std::string nbtFilepath;
    std::cout << "Please input the 'NBT file path':" << std::endl;
    std::cin >> nbtFilepath;

    bool isBigEndian;
    std::cout << "Whether to the 'NBT file' is big endian? Y/N:" << std::endl;
    int key;
    while (true) {
        key = getchar();
        if (key == 'Y' || key == 'y') {
            isBigEndian = true;
            break;
        } else if (key == 'N' || key == 'n') {
            isBigEndian = false;
            break;
        } else {
            std::cout << "Please input Y/N:" << std::endl;
            continue;
        }
    }
    auto nbt = readNbt(nbtFilepath, isBigEndian);
    std::cout << nbt.toSnbt() << std::endl;
    std::cout << "The Part 1 Is End\n" << std::endl;

    std::cout << "The Part 2<Get A Example NBT And Create Files>\n---------------------------------" << std::endl;
    Nbt::Tag root = getExampleCompound();
    getAllTypeFiles(root);
    std::cout << "The Part 2 Is End" << std::endl;

    return 0;
}
